# Лабораторная №2
**Дисциплина:** Низкоуровневое программирование<br/>
**Вариант:** 6 (*Gremlin*)<br/>
**Отчёт:** [report.pdf](https://github.com/ANegrash/LowLevelProg_lab2/blob/master/report.pdf)
## Задание
Использовать средство синтаксического анализа по выбору, реализовать модуль для разбора некоторого достаточного подмножества языка запросов по выбору в соответствии с вариантом формы данных. Должна быть обеспечена возможность описания команд создания, выборки, модификации и удаления элементов данных.
## Выполнение
Код лабораторной работы доступен по [ссылке](https://github.com/ANegrash/LowLevelProg_lab2)
### Часть 1: выбор средства синтаксического анализа
В качестве средства синтаксического анализа были выбраны следующие утилиты:
- **Flex** (используется для разбиения входного потока данных на лексемы)
- **Bison** (обрабатывает набор, полученный от Flex, согласно описанным правилам)
### Часть 2: синтаксис языка запросов и запись спецификации
Примеры составления запросов на языке Gremlin были взяты с [официального сайта](https://docs.janusgraph.org/getting-started/gremlin/)<br/>
На основе просмотренных данных были составлены следующие типы запросов:
- Создание файла: <br/>`create("file.txt");`
-	Открытие уже созданного файла: <br/>`open("file.txt");`
-	Закрытие файла: <br/>`close();`
-	Добавление схемы: <br/>`addSchema("schema_name", "fist_attr", <attr_type>, "second_attr", <attr_type>, …);`
-	Удаление схемы: <br/>`deleteSchema("schema_name");`
-	Добавление записи: <br/>`addVertex("schema_name", "attr_name", <attr_value>, …);`
-	Получение всех элементов схемы: <br/>`V("schema_name");`
-	Получение элементов схемы, соответствующих набору условий значений атрибутов: <br/>`V("schema_name").has("attr_name", <select_option>(<select_value>), …);`
-	Получение записей, ассоциированных с ключевой схемой по ребру: <br/>`V("schema_name").out("edge_name");`
-	Удаление элементов схемы: <br/>`V("schema_name").delete();`

Запрос может содержать чередование условий выборки элементов с соединением по рёбрам. Команда удаления элементов может быть использована в сочетании с выборкой по условиям.

Доступны следующие условия выборки элементов данных:
- Равенство: <br/>`eq(<attr_value>)`
-	Неравенство: <br/>`neq(<attr_value>)`
-	Строго больше: <br/>`gt(<attr_value>)`
-	Больше или равно: <br/>`gte(<attr_value>)`
-	Строго меньше: <br/>`lt(<attr_value>)`
-	Меньше или равно: <br/>`lte(<attr_value>)`
-	Включение подстроки: <br/>`like(<substr>)`

### Часть 3: реализация модуля разбора языка запросов
Реализация находится в файлах [`lexer.l`](https://github.com/ANegrash/LowLevelProg_lab2/blob/master/lexer.l) и [`parser.y`](https://github.com/ANegrash/LowLevelProg_lab2/blob/master/parser.y)

Структура дерева составления запросов описана в файле [`request_tree.h`](https://github.com/ANegrash/LowLevelProg_lab2/blob/master/request_tree.h)

## Вывод
Итак, в ходе выполнения данной лабораторной работы я рассмотрел грамматику языка запросов Gremlin, на основе которой была записана спецификация для утилит синтаксического анализа. Я задействовал такие инструменты, как Flex и Bison.<br/>
Созданная спецификация позволяет составить запросы для работы непосредственно с файлом данных (операции открытия, создания, удаления), осуществляет работу со схемами (операции добавления и удаления схем), позволяет добавлять элементы данных с указанием значений атрибутов, а также составлять запросы на поиск элементов данных согласно заданным условиям.<br/>
Был реализован модуль, способный производить синтаксический разбор запроса и на его основе составлять дерево запроса. Полученное дерево может быть представлено в текстовом виде.


